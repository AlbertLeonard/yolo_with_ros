#!/usr/bin/env python

import rospy
import tf
import tf2_ros

import std_msgs
import geometry_msgs
from sensor_msgs.msg import JointState

from msg_gateway.msg import Command_msgs
from msg_gateway.srv import MoveArm, MoveArmResponse

import os
import os.path
import shutil
#i = 1

def arm_rest():
	
	pose_target.orientation.w = 1
	pose_target.position.x = 0.155
	pose_target.position.y = 0
	pose_target.position.z = 0.241
	
def arm_stand_by():
	
	pose_target.orientation.w = 1.0
	pose_target.position.x = 0.4
	pose_target.position.y = 0
	pose_target.position.z = 0.45
	
def arm_left_pose():
	
	pose_target.orientation.w = 1.0
	pose_target.position.x = 0.4#0.3
	pose_target.position.y = 0#0.158#0.4
	pose_target.position.z = 0.162#0.085
	
def arm_rightward():
	
	#pose_target.orientation.w = 1.0
	#pose_target.position.x = 0.4
	pose_target.position.y = pose_target.position.y - 0.01
	#pose_target.position.z = 0.45
	
def arm_grip():
	
	pose_target.position.x = pose_target.position.x + 0.03
	
def arm_grip_():
	
	pose_target.position.x = pose_target.position.x - 0.03
	

def callback(command):
	
	global pose_target, COMMAND
	
	if True: #command.START_ == 1:
		
		x_ = 0.001 *  command.LS_V
		y_ = 0.001 *  command.LS_H
		z_ = 0.001 * (command.R - command.L)
		
		roll_  =  1.4 * (command.RB - command.LB) - roll_offset         # X
		yaw_   =  1.4 *  command.RS_V             - yaw_offset          # Y
		pitch_ = -1.4 *  command.RS_H             - pitch_offset        # Z
		
		COMMAND = command
	
		q = tf.transformations.quaternion_from_euler(roll_, yaw_, pitch_)
	
		#print '......'
		#print x_
		#print y_
		#print z_
		#print roll_
		#print yaw_
		#print pitch_
		#print '......'
		
		if command.DP_V == 1:
		
			arm_stand_by()
			
		
		if command.DP_H == 1:
		
			arm_rest()
			
		if command.DP_V == -1:
		
			arm_left_pose()
			
		
		if command.DP_H == -1:
		
			arm_rightward()
			
		if command.A == 1:
			
			arm_grip()
			
		if command.Y == 1:
			
			arm_grip_()
			
		else:
		
			pose_target.orientation.x = q[0]
			pose_target.orientation.y = q[1]
			pose_target.orientation.z = q[2]
			pose_target.orientation.w = q[3]
	
			#print '......'
			#print q[0]
			#print q[1]
			#print q[2]
			#print q[3]
			#print '......'
	
			pose_target.position.x = pose_target.position.x + x_
			pose_target.position.y = pose_target.position.y + y_
			pose_target.position.z = pose_target.position.z + z_
			
			print pose_target.position.x
			print pose_target.position.y
			print pose_target.position.z
				
	else:
		
		arm_stand_by()

pose_target = geometry_msgs.msg.Pose()


roll_offset  =  0
yaw_offset   =  0#-0.12
pitch_offset =  0

q = tf.transformations.quaternion_from_euler(roll_offset, yaw_offset, pitch_offset)

pose_target.orientation.x = q[0]
pose_target.orientation.y = q[1]
pose_target.orientation.z = q[2]
pose_target.orientation.w = q[3]
pose_target.position.x = 0.4
pose_target.position.y = 0
pose_target.position.z = 0.45

COMMAND = Command_msgs()

rospy.init_node("command_bridge_arm_joy")

#robot = moveit_commander.RobotCommander()
#scene = moveit_commander.PlanningSceneInterface()
#group = moveit_commander.MoveGroupCommander("my_arm")

sub = rospy.Subscriber('command_control', Command_msgs, callback)

rospy.wait_for_service('move_arm')
move_arm_joy = rospy.ServiceProxy('move_arm', MoveArm)

rospy.loginfo("Command_Bridge_Arm_Joy...")

result = move_arm_joy(0.4, 0, 0.45, 0, 0, 0)
result = move_arm_joy(0.155, 0, 0.241, 0, 0, 0)

#shutil.copy(r'/home/yonh_dee/Desktop/test/1', '/home/yonh_dee/Desktop/u') 
#print 'file copyed'

rate = rospy.Rate(30) # 30hz

while not rospy.is_shutdown():
	
	r =  1.0 * (COMMAND.RB - COMMAND.LB) - roll_offset         # X
	y =  2.0 *  COMMAND.RS_V             - yaw_offset          # Y
	p = -2.0 *  COMMAND.RS_H             - pitch_offset        # Z
	
	result = move_arm_joy(pose_target.position.x,
						  pose_target.position.y,
						  pose_target.position.z,
						  r, y, p)
	#group.go(wait=True)
	rospy.sleep(1)
	
	rate.sleep()
